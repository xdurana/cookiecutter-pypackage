{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Cookiecutter PyPackage \u00b6 This is a cookiecutter repository to generate the file structure for a Python project that uses Poetry for its dependency management. A project generated with cookiecutter-pypackage supports the following features: Poetry , obviously. CI/CD with GitHub Actions Formatting with black and isort Linting with flake8 Publishing to Pypi by creating a new release on GitHub Testing with pytest Documentation with MkDocs Static type checking with mypy Compatibility testing for multiple versions of Python with Tox Containerization with Docker Developing inside a Container in VSCode An example of a repository generated with this package can be found here . Quickstart \u00b6 On your local machine, navigate to the directory in which you want to create a project directory, and run the following two commands: pip install cookiecutter-pypackage ccp Alternatively, install cookiecutter and directly pass the URL to this Github repository to the cookiecutter command: pip install cookiecutter cookiecutter https://github.com/{{cookiecutter.author_github_handle}}/cookiecutter-pypackage.git Then run the following commands, replacing <project-name> , with the name that you also gave the Github repository and <github_author_handle> with your Github username. cd <project_name> git init -b main git add . git commit -m \"Init commit\" git remote add origin git@github.com:<github_author_handle>/<project_name>.git git push -u origin main Finally, install the environment with make install . You are now ready to start development on your project! The CI/CD pipeline will be triggered when you open a pull request, merge to main, or when you create a new release. To finalize the set-up for publishing to PyPi, see here . For activating the automatic documentation with MkDocs, see here . Acknowledgements \u00b6 This project is partially based on Audrey Feldroy's great cookiecutter-pypackage and Florian Maas great cookiecutter-poetry .","title":"Home"},{"location":"#cookiecutter-pypackage","text":"This is a cookiecutter repository to generate the file structure for a Python project that uses Poetry for its dependency management. A project generated with cookiecutter-pypackage supports the following features: Poetry , obviously. CI/CD with GitHub Actions Formatting with black and isort Linting with flake8 Publishing to Pypi by creating a new release on GitHub Testing with pytest Documentation with MkDocs Static type checking with mypy Compatibility testing for multiple versions of Python with Tox Containerization with Docker Developing inside a Container in VSCode An example of a repository generated with this package can be found here .","title":"Cookiecutter PyPackage"},{"location":"#quickstart","text":"On your local machine, navigate to the directory in which you want to create a project directory, and run the following two commands: pip install cookiecutter-pypackage ccp Alternatively, install cookiecutter and directly pass the URL to this Github repository to the cookiecutter command: pip install cookiecutter cookiecutter https://github.com/{{cookiecutter.author_github_handle}}/cookiecutter-pypackage.git Then run the following commands, replacing <project-name> , with the name that you also gave the Github repository and <github_author_handle> with your Github username. cd <project_name> git init -b main git add . git commit -m \"Init commit\" git remote add origin git@github.com:<github_author_handle>/<project_name>.git git push -u origin main Finally, install the environment with make install . You are now ready to start development on your project! The CI/CD pipeline will be triggered when you open a pull request, merge to main, or when you create a new release. To finalize the set-up for publishing to PyPi, see here . For activating the automatic documentation with MkDocs, see here .","title":"Quickstart"},{"location":"#acknowledgements","text":"This project is partially based on Audrey Feldroy's great cookiecutter-pypackage and Florian Maas great cookiecutter-poetry .","title":"Acknowledgements"},{"location":"prompt_arguments/","text":"Prompt arguments \u00b6 When running the command ccp a prompt will start which enables you to configure your repository. The prompt values and their explanation are as follows: author Your full name. email Your email address. author_github_handle Your github handle, i.e. <handle> in https://github.com/<handle> project_name Your project name. Should be equal to the name of your repository and it should only contain alphanumeric characters and - 's. project_slug The project slug, will default to the project_name with all - 's replaced with _ . This will be how you import your code later, e.g. from <project_slug import foo project_description A short description of your project. include_github_actions \"y\" or \"n\" . Adds a .github directory with various actions and workflows to setup the environment and run code formatting checks and unittests. publish_to \"pypi\" or \"none\" . Adds functionality to the Makefile and Github workflows to make publishing your code as simple as creating a new release release on Github. For more info, see Publishing to Pypi . mkdocs \"y\" or \"n\" . Adds MkDocs documentation to your project. This includes automatically parsing your docstrings and adding them to the documentation. Documentation will be deployed to the gh-pages branch. tox \"y\" or \"n\" . Adds automatic Tox testing for compatibility with multiple versions of Python. mypy \"y\" or \"n\" . Adds automatic static type checking with mypy . dockerfile \"y\" or \"n\" . Adds a simple Dockerfile . open_source_license Choose a license . Options: [\"1. MIT License\", \"2. BSD license\", \"3. ISC license\", \"4. Apache Software License 2.0\", \"5. GNU General Public License v3\", \"6. Not open source\"]","title":"Prompt Arguments"},{"location":"prompt_arguments/#prompt-arguments","text":"When running the command ccp a prompt will start which enables you to configure your repository. The prompt values and their explanation are as follows: author Your full name. email Your email address. author_github_handle Your github handle, i.e. <handle> in https://github.com/<handle> project_name Your project name. Should be equal to the name of your repository and it should only contain alphanumeric characters and - 's. project_slug The project slug, will default to the project_name with all - 's replaced with _ . This will be how you import your code later, e.g. from <project_slug import foo project_description A short description of your project. include_github_actions \"y\" or \"n\" . Adds a .github directory with various actions and workflows to setup the environment and run code formatting checks and unittests. publish_to \"pypi\" or \"none\" . Adds functionality to the Makefile and Github workflows to make publishing your code as simple as creating a new release release on Github. For more info, see Publishing to Pypi . mkdocs \"y\" or \"n\" . Adds MkDocs documentation to your project. This includes automatically parsing your docstrings and adding them to the documentation. Documentation will be deployed to the gh-pages branch. tox \"y\" or \"n\" . Adds automatic Tox testing for compatibility with multiple versions of Python. mypy \"y\" or \"n\" . Adds automatic static type checking with mypy . dockerfile \"y\" or \"n\" . Adds a simple Dockerfile . open_source_license Choose a license . Options: [\"1. MIT License\", \"2. BSD license\", \"3. ISC license\", \"4. Apache Software License 2.0\", \"5. GNU General Public License v3\", \"6. Not open source\"]","title":"Prompt arguments"},{"location":"tutorial/","text":"Tutorial \u00b6 This page contains a complete tutorial on how to create your project. Step 1: Install poetry \u00b6 To start, we will need to install poetry . The instructions to install poetry can be found here . After installing, it is recommended to run poetry config virtualenvs.in-project true which will by default create new virtual environments in ./.venv whenever you create them with poetry init . Step 2: Install pyenv (Optional) \u00b6 I would recommend to use pyenv for managing your different Python versions. However, if you prefer another method of managing your Python versions, feel free to skip this step and continue to step 3 . The instructions to install pyenv can be found here . The instructions to install poetry can be found here . Install a version of Python with pyenv. To see a list of available versions, run: pyenv install --list Select a version and install it with pyenv install -v 3.9.7 Replacing 3.9.7 with a version of your choosing. Step 3: Generate your project \u00b6 First, navigate to the directory in which you want the project to be created. Then, we need to install cookiecutter-pypackage with the following command: pip install cookiecutter-pypackage Within the directory in which you want to create your project, run: ccp For an explanation of the prompt arguments, see Prompt Arguments . An alternative to the steps above would be to install cookiecutter and directly pass the URL to Github repository to the cookiecutter command: pip install cookiecutter-pypackage cookiecutter https://github.com/xdurana/cookiecutter-pypackage.git Step 4: Set up your Github repository \u00b6 Create an empty new repository on Github. Give it a name that only contains alphanumeric characters and optionally - . DO NOT check any boxes under the option Initialize this repository with . Step 5: Upload your project to Github \u00b6 Run the following commands, replacing <project-name> with the name that you also gave the Github repository and <github_author_handle> with your Github username. cd <project_name> git init -b main git add . git commit -m \"Init commit\" git remote add origin git@github.com:<github_author_handle>/<project_name>.git git push -u origin main Step 6: Activate your environment \u00b6 If you are using pyenv , you might want to set the local python version to be used: pyenv local x.y.z Install and activate the poetry environment by running: poetry install poetry shell Step 7: Configure your repository secrets \u00b6 If you want to deploy your project to Pypi using the Github Actions, you will have to set some repository secrets. For instructions on how to do that, see here for PyPi. Step 8: Create a new release \u00b6 To trigger a new release, navigate to your repository on GitHub, click Releases on the right, and then select Draft a new release . If you fail to find the button, you could also directly visit https://github.com/<username>/<repository-name>/releases/new . Give your release a title, and add a new tag in the form *.*.* where the * 's are alphanumeric. To finish, press Publish release . Step 9: Enable your documentation \u00b6 In your repository, navigate to Settings > Code and Automation > Pages . If you succesfully created a new release, you should see a notification saying Your site is ready to be published at https://<author_github_handle>.github.io/<project_name>/ . To finalize deploying your documentation, under Source , select the branch gh-pages . Step 10: You're all set! \u00b6 That's it! I hope this repository saved you a lot of manual configuration. If you have any improvement suggestions, feel free to raise an issue or open a PR on Github!","title":"Tutorial"},{"location":"tutorial/#tutorial","text":"This page contains a complete tutorial on how to create your project.","title":"Tutorial"},{"location":"tutorial/#step-1-install-poetry","text":"To start, we will need to install poetry . The instructions to install poetry can be found here . After installing, it is recommended to run poetry config virtualenvs.in-project true which will by default create new virtual environments in ./.venv whenever you create them with poetry init .","title":"Step 1: Install poetry"},{"location":"tutorial/#step-2-install-pyenv-optional","text":"I would recommend to use pyenv for managing your different Python versions. However, if you prefer another method of managing your Python versions, feel free to skip this step and continue to step 3 . The instructions to install pyenv can be found here . The instructions to install poetry can be found here . Install a version of Python with pyenv. To see a list of available versions, run: pyenv install --list Select a version and install it with pyenv install -v 3.9.7 Replacing 3.9.7 with a version of your choosing.","title":"Step 2: Install pyenv (Optional)"},{"location":"tutorial/#step-3-generate-your-project","text":"First, navigate to the directory in which you want the project to be created. Then, we need to install cookiecutter-pypackage with the following command: pip install cookiecutter-pypackage Within the directory in which you want to create your project, run: ccp For an explanation of the prompt arguments, see Prompt Arguments . An alternative to the steps above would be to install cookiecutter and directly pass the URL to Github repository to the cookiecutter command: pip install cookiecutter-pypackage cookiecutter https://github.com/xdurana/cookiecutter-pypackage.git","title":"Step 3: Generate your project"},{"location":"tutorial/#step-4-set-up-your-github-repository","text":"Create an empty new repository on Github. Give it a name that only contains alphanumeric characters and optionally - . DO NOT check any boxes under the option Initialize this repository with .","title":"Step 4: Set up your Github repository"},{"location":"tutorial/#step-5-upload-your-project-to-github","text":"Run the following commands, replacing <project-name> with the name that you also gave the Github repository and <github_author_handle> with your Github username. cd <project_name> git init -b main git add . git commit -m \"Init commit\" git remote add origin git@github.com:<github_author_handle>/<project_name>.git git push -u origin main","title":"Step 5: Upload your project to Github"},{"location":"tutorial/#step-6-activate-your-environment","text":"If you are using pyenv , you might want to set the local python version to be used: pyenv local x.y.z Install and activate the poetry environment by running: poetry install poetry shell","title":"Step 6: Activate your environment"},{"location":"tutorial/#step-7-configure-your-repository-secrets","text":"If you want to deploy your project to Pypi using the Github Actions, you will have to set some repository secrets. For instructions on how to do that, see here for PyPi.","title":"Step 7: Configure your repository secrets"},{"location":"tutorial/#step-8-create-a-new-release","text":"To trigger a new release, navigate to your repository on GitHub, click Releases on the right, and then select Draft a new release . If you fail to find the button, you could also directly visit https://github.com/<username>/<repository-name>/releases/new . Give your release a title, and add a new tag in the form *.*.* where the * 's are alphanumeric. To finish, press Publish release .","title":"Step 8: Create a new release"},{"location":"tutorial/#step-9-enable-your-documentation","text":"In your repository, navigate to Settings > Code and Automation > Pages . If you succesfully created a new release, you should see a notification saying Your site is ready to be published at https://<author_github_handle>.github.io/<project_name>/ . To finalize deploying your documentation, under Source , select the branch gh-pages .","title":"Step 9: Enable your documentation"},{"location":"tutorial/#step-10-youre-all-set","text":"That's it! I hope this repository saved you a lot of manual configuration. If you have any improvement suggestions, feel free to raise an issue or open a PR on Github!","title":"Step 10: You're all set!"},{"location":"features/cicd/","text":"CI/CD with Github actions \u00b6 when include_github_actions is set to \"y\" , a .github directory is added with the following structure: .github \u251c\u2500\u2500 workflows \u251c\u2500\u2500\u2500 run-checks \u2502 \u2514\u2500\u2500 action.yml \u251c\u2500\u2500\u2500 setup-poetry-env \u2502 \u2514\u2500\u2500 action.yml \u251c\u2500\u2500 on-merge-to-main.yml \u251c\u2500\u2500 on-pull-request.yml \u2514\u2500\u2500 on-release-main.yml on-merge-to-main.yml and on-pull-request.yml are identical except for their trigger conditions; the first is run whenever a new commit is made to main (which should only happen through merge requests, hence the name), and the latter is run whenever a pull request is opened or updated. They call the action.yml files to set-up the environment, run the tests, and check the code formatting. on-release-main.yml does all of the former whenever a new release is made on the main branch. In addition, on-release-main.yml also publishes the project to Pypi if publish_to is set to \"pypi\" , and it builds and deploys the documentation if mkdocs is set to \"y\" . To learn more about these features, see Publishing to PyPi and Documentation with MkDocs Additionally, all workflows check for compatibility with multiple Python versions if tox is set to \"y\" . How to trigger a release? \u00b6 To trigger a new release, navigate to your repository on GitHub, click Releases on the right, and then select Draft a new release . If you fail to find the button, you could also directly visit https://github.com/<username>/<repository-name>/releases/new . Give your release a title, and add a new tag in the form *.*.* where the * 's are alphanumeric. To finish, press Publish release .","title":"CI/CD with Github Actions"},{"location":"features/cicd/#cicd-with-github-actions","text":"when include_github_actions is set to \"y\" , a .github directory is added with the following structure: .github \u251c\u2500\u2500 workflows \u251c\u2500\u2500\u2500 run-checks \u2502 \u2514\u2500\u2500 action.yml \u251c\u2500\u2500\u2500 setup-poetry-env \u2502 \u2514\u2500\u2500 action.yml \u251c\u2500\u2500 on-merge-to-main.yml \u251c\u2500\u2500 on-pull-request.yml \u2514\u2500\u2500 on-release-main.yml on-merge-to-main.yml and on-pull-request.yml are identical except for their trigger conditions; the first is run whenever a new commit is made to main (which should only happen through merge requests, hence the name), and the latter is run whenever a pull request is opened or updated. They call the action.yml files to set-up the environment, run the tests, and check the code formatting. on-release-main.yml does all of the former whenever a new release is made on the main branch. In addition, on-release-main.yml also publishes the project to Pypi if publish_to is set to \"pypi\" , and it builds and deploys the documentation if mkdocs is set to \"y\" . To learn more about these features, see Publishing to PyPi and Documentation with MkDocs Additionally, all workflows check for compatibility with multiple Python versions if tox is set to \"y\" .","title":"CI/CD with Github actions"},{"location":"features/cicd/#how-to-trigger-a-release","text":"To trigger a new release, navigate to your repository on GitHub, click Releases on the right, and then select Draft a new release . If you fail to find the button, you could also directly visit https://github.com/<username>/<repository-name>/releases/new . Give your release a title, and add a new tag in the form *.*.* where the * 's are alphanumeric. To finish, press Publish release .","title":"How to trigger a release?"},{"location":"features/docker/","text":"Containerization with Docker \u00b6 If dockerfile is set to \"y\" , a simple Dockerfile is added to the repository. The Dockerfile installs poetry, sets up the environment and runs foo.py when run. The docker image can be built with docker build . -t my-docker-image It can then be run in the background with docker run -d my-docker-image Or, run it interactive mode with docker run --rm -it --entrypoint bash my-docker-image","title":"Containerization with Docker"},{"location":"features/docker/#containerization-with-docker","text":"If dockerfile is set to \"y\" , a simple Dockerfile is added to the repository. The Dockerfile installs poetry, sets up the environment and runs foo.py when run. The docker image can be built with docker build . -t my-docker-image It can then be run in the background with docker run -d my-docker-image Or, run it interactive mode with docker run --rm -it --entrypoint bash my-docker-image","title":"Containerization with Docker"},{"location":"features/formatting/","text":"Formatting with black and isort \u00b6 isort and black are added as development dependencies. black and isort can be used to format the code with make format And the code style can be checked with make check Settings for both black and isort can be edited in pyproject.toml . The default settings are: [tool.black] line-length = 120 include = '\\.pyi?$' target-version = ['py39'] fast = true exclude = ''' ( /( # exclude a few common directories in the \\.git # root of the project | \\.pytest_cache | python-venv | \\.venv | build | dist | \\.tox )) ''' [tool.isort] profile = \"black\" If include_github_actions is set to \"y\" , code formatting is checked for every merge request, every merge to main, and every release.","title":"Formatting with black and isort"},{"location":"features/formatting/#formatting-with-black-and-isort","text":"isort and black are added as development dependencies. black and isort can be used to format the code with make format And the code style can be checked with make check Settings for both black and isort can be edited in pyproject.toml . The default settings are: [tool.black] line-length = 120 include = '\\.pyi?$' target-version = ['py39'] fast = true exclude = ''' ( /( # exclude a few common directories in the \\.git # root of the project | \\.pytest_cache | python-venv | \\.venv | build | dist | \\.tox )) ''' [tool.isort] profile = \"black\" If include_github_actions is set to \"y\" , code formatting is checked for every merge request, every merge to main, and every release.","title":"Formatting with black and isort"},{"location":"features/linting/","text":"Linting with flake8 \u00b6 flake8 is added as development dependency. The settings for flake8 can be found in tox.ini , and they are defaulted to: [flake8] per-file-ignores = __init__.py:F401 # PEP-8 The following are ignored: # E731 do not assign a lambda expression, use a def # E203 whitespace before ':' # E501 line too long # W503 line break before binary operator # W605 invalid escape sequence ignore = E731, E203, E501, W503, W605 exclude = .git, __pycache__, docs/source/conf.py, old, build, dist, .venv, max-complexity = 10 max-line-length = 120 If include_github_actions is set to \"y\" , code linting is checked with flake8 for every merge request, every merge to main, and every release.","title":"Linting with flake8"},{"location":"features/linting/#linting-with-flake8","text":"flake8 is added as development dependency. The settings for flake8 can be found in tox.ini , and they are defaulted to: [flake8] per-file-ignores = __init__.py:F401 # PEP-8 The following are ignored: # E731 do not assign a lambda expression, use a def # E203 whitespace before ':' # E501 line too long # W503 line break before binary operator # W605 invalid escape sequence ignore = E731, E203, E501, W503, W605 exclude = .git, __pycache__, docs/source/conf.py, old, build, dist, .venv, max-complexity = 10 max-line-length = 120 If include_github_actions is set to \"y\" , code linting is checked with flake8 for every merge request, every merge to main, and every release.","title":"Linting with flake8"},{"location":"features/makefile/","text":"Makefile \u00b6 The generated repository will have a Makefile available. A list of all available commands that are available can be obtained by running make help in the terminal. Initially, if all features are selected, the following commands are available: install Install the poetry environment format Format code using isort and black. check Check code formatting using isort, black, flake8 and mypy. test Test the code with pytest mypy Check types with mypy build Build wheel file using poetry clean-build clean build artifacts publish publish a release to pypi. build-and-publish Build and publish. docs-generate convert docstrings to docs docs-build Build the docs docs-open Open the docs in the browser docs Build and serve the documentation docs-test Test if the documentation can be generated and built without errors.","title":"Makefile"},{"location":"features/makefile/#makefile","text":"The generated repository will have a Makefile available. A list of all available commands that are available can be obtained by running make help in the terminal. Initially, if all features are selected, the following commands are available: install Install the poetry environment format Format code using isort and black. check Check code formatting using isort, black, flake8 and mypy. test Test the code with pytest mypy Check types with mypy build Build wheel file using poetry clean-build clean build artifacts publish publish a release to pypi. build-and-publish Build and publish. docs-generate convert docstrings to docs docs-build Build the docs docs-open Open the docs in the browser docs Build and serve the documentation docs-test Test if the documentation can be generated and built without errors.","title":"Makefile"},{"location":"features/mkdocs/","text":"Documentation with MkDocs \u00b6 If mkdocs is set to \"y\" , documentation of your project is automatically added using MkDocs . Next to that, if \"include_github_actions\" is set to \"y\" , the documentation is automatically deployed to your gh-pages branch, and made available at https://<github_handle>.github.io/<project_name>/ . To view the documentation locally, simply run make docs This command will generate, and build your documentation, and start the server locally so you can access it at http://localhost:8000 . Enabling the documentation on GitHub \u00b6 To enable your documentation on GitHub, first create a new release . Then, in your repository, navigate to Settings > Code and Automation > Pages . If you succesfully created a new release, you should see a notification saying Your site is ready to be published at https://<author_github_handle>.github.io/<project_name>/ . To finalize deploying your documentation, under Source , select the branch gh-pages . Your documentation should then be live within a few minutes. Documenting docstrings \u00b6 The generated project also converts all your docstrings into legible documentation. By default, the project is configured to work with google style docstrings. An example of a Google style docstring: def function_with_pep484_type_annotations(param1: int, param2: str) -> bool: \"\"\"Example function with PEP 484 type annotations. Args: param1: The first parameter. param2: The second parameter. Returns: The return value. True for success, False otherwise. For more examples, see here .","title":"Documentation with MkDocs"},{"location":"features/mkdocs/#documentation-with-mkdocs","text":"If mkdocs is set to \"y\" , documentation of your project is automatically added using MkDocs . Next to that, if \"include_github_actions\" is set to \"y\" , the documentation is automatically deployed to your gh-pages branch, and made available at https://<github_handle>.github.io/<project_name>/ . To view the documentation locally, simply run make docs This command will generate, and build your documentation, and start the server locally so you can access it at http://localhost:8000 .","title":"Documentation with MkDocs"},{"location":"features/mkdocs/#enabling-the-documentation-on-github","text":"To enable your documentation on GitHub, first create a new release . Then, in your repository, navigate to Settings > Code and Automation > Pages . If you succesfully created a new release, you should see a notification saying Your site is ready to be published at https://<author_github_handle>.github.io/<project_name>/ . To finalize deploying your documentation, under Source , select the branch gh-pages . Your documentation should then be live within a few minutes.","title":"Enabling the documentation on GitHub"},{"location":"features/mkdocs/#documenting-docstrings","text":"The generated project also converts all your docstrings into legible documentation. By default, the project is configured to work with google style docstrings. An example of a Google style docstring: def function_with_pep484_type_annotations(param1: int, param2: str) -> bool: \"\"\"Example function with PEP 484 type annotations. Args: param1: The first parameter. param2: The second parameter. Returns: The return value. True for success, False otherwise. For more examples, see here .","title":"Documenting docstrings"},{"location":"features/mypy/","text":"Static type checking with Mypy \u00b6 If mypy is set to \"y\" , static type checking is added with mypy . If \"github_actions is also set to \"y\" , the code is checked with mypy during every workflow that is triggered. The default configuration is as shown below, and can be edited in pyproject.toml . [tool.mypy] disallow_untyped_defs = \"True\" disallow_any_unimported = \"True\" no_implicit_optional = \"True\" check_untyped_defs = \"True\" warn_return_any = \"True\" warn_unused_ignores = \"True\" show_error_codes = \"True\" exclude = [ '\\.venv', '{{cookiecutter.project_name}}', 'tests' ]","title":"Static type checking with mypy"},{"location":"features/mypy/#static-type-checking-with-mypy","text":"If mypy is set to \"y\" , static type checking is added with mypy . If \"github_actions is also set to \"y\" , the code is checked with mypy during every workflow that is triggered. The default configuration is as shown below, and can be edited in pyproject.toml . [tool.mypy] disallow_untyped_defs = \"True\" disallow_any_unimported = \"True\" no_implicit_optional = \"True\" check_untyped_defs = \"True\" warn_return_any = \"True\" warn_unused_ignores = \"True\" show_error_codes = \"True\" exclude = [ '\\.venv', '{{cookiecutter.project_name}}', 'tests' ]","title":"Static type checking with Mypy"},{"location":"features/poetry/","text":"Dependency management with Poetry \u00b6 The generated repository will uses Poetry for its dependency management. When you have created your repository using this cookiecutter template, a Poetry environment is pre-configured in pyproject.toml and Poetry.toml . All you need to do is add your project-specific dependencies with poetry add <package> and then install the environment with make install By default, the environment is created in a .venv folder, so you can easily start an interactive shell within the environment with poetry shell .","title":"Dependency management with Poetry"},{"location":"features/poetry/#dependency-management-with-poetry","text":"The generated repository will uses Poetry for its dependency management. When you have created your repository using this cookiecutter template, a Poetry environment is pre-configured in pyproject.toml and Poetry.toml . All you need to do is add your project-specific dependencies with poetry add <package> and then install the environment with make install By default, the environment is created in a .venv folder, so you can easily start an interactive shell within the environment with poetry shell .","title":"Dependency management with Poetry"},{"location":"features/publishing/","text":"Publishing to Pypi \u00b6 Releasing from Github \u00b6 When publish_to is set to \"pypi\", the on-release-main.yml` workflow publishes the code to Pypi whenever a new release is made. Before you can succesfully publish your project from the release workflow, you need to add some secrets to your github repository so they can be used as environment variables. Set-up for Pypi \u00b6 In order to publish to Pypi, the secret PYPI_TOKEN should be set in your repository. In your Github repository, navigate to Settings > Secrets > Actions and press New repository secret . As the name of the secret, set PYPI_TOKEN . Then, in a new tab go to your Pypi Account settings and select Add API token . Copy and paste the token in the Value field for the Github secret in your first tab, and you're all set! Publishing from your local machine \u00b6 It is also possible to release locally, although it is not recommended. To do so, set the repository secrets listed in the sections above as environment variables on your local machine instead, and run make build-and-publish","title":"Publishing to PyPi"},{"location":"features/publishing/#publishing-to-pypi","text":"","title":"Publishing to Pypi"},{"location":"features/publishing/#releasing-from-github","text":"When publish_to is set to \"pypi\", the on-release-main.yml` workflow publishes the code to Pypi whenever a new release is made. Before you can succesfully publish your project from the release workflow, you need to add some secrets to your github repository so they can be used as environment variables.","title":"Releasing from Github"},{"location":"features/publishing/#set-up-for-pypi","text":"In order to publish to Pypi, the secret PYPI_TOKEN should be set in your repository. In your Github repository, navigate to Settings > Secrets > Actions and press New repository secret . As the name of the secret, set PYPI_TOKEN . Then, in a new tab go to your Pypi Account settings and select Add API token . Copy and paste the token in the Value field for the Github secret in your first tab, and you're all set!","title":"Set-up for Pypi"},{"location":"features/publishing/#publishing-from-your-local-machine","text":"It is also possible to release locally, although it is not recommended. To do so, set the repository secrets listed in the sections above as environment variables on your local machine instead, and run make build-and-publish","title":"Publishing from your local machine"},{"location":"features/pytest/","text":"Unittesting with Pytest \u00b6 pytest is automatically added to the environment. There will be a template unittest in the tests directory upon creation of the project, which can be run with make test If include_github_actions is set to \"y\" , the tests are automatically run for every merge request, every merge to main, and every release.","title":"Testing with Pytest"},{"location":"features/pytest/#unittesting-with-pytest","text":"pytest is automatically added to the environment. There will be a template unittest in the tests directory upon creation of the project, which can be run with make test If include_github_actions is set to \"y\" , the tests are automatically run for every merge request, every merge to main, and every release.","title":"Unittesting with Pytest"},{"location":"features/tox/","text":"Compatibility testing with Tox \u00b6 If tox is set to \"y\" project uses Tox to test compatibility with multiple Python versions. By default, the project is tested with Python 3.8 , 3.9 , and 3.10 . Testing is done automatically in the CI/CD pipeline on every pull request, merge to main, and on each release. If you want to add more Python versions you can simply add them to tox.ini and to the separate workflows in .github .","title":"Compatibility testing with Tox"},{"location":"features/tox/#compatibility-testing-with-tox","text":"If tox is set to \"y\" project uses Tox to test compatibility with multiple Python versions. By default, the project is tested with Python 3.8 , 3.9 , and 3.10 . Testing is done automatically in the CI/CD pipeline on every pull request, merge to main, and on each release. If you want to add more Python versions you can simply add them to tox.ini and to the separate workflows in .github .","title":"Compatibility testing with Tox"},{"location":"features/vscode/","text":"Developing inside a Container in VSCode \u00b6 The Visual Studio Code Remote - Containers extension lets you use a Docker container as a full-featured development environment. It allows you to open any folder inside (or mounted into) a container and take advantage of Visual Studio Code's full feature set. A devcontainer.json file in your project tells VS Code how to access (or create) a development container with a well-defined tool and runtime stack. This container can be used to run an application or to separate tools, libraries, or runtimes needed for working with a codebase. If you open the project in VSCode, you can reopen the folder in the development container and have a full working environment.","title":"Developing inside a Container in VSCode"},{"location":"features/vscode/#developing-inside-a-container-in-vscode","text":"The Visual Studio Code Remote - Containers extension lets you use a Docker container as a full-featured development environment. It allows you to open any folder inside (or mounted into) a container and take advantage of Visual Studio Code's full feature set. A devcontainer.json file in your project tells VS Code how to access (or create) a development container with a well-defined tool and runtime stack. This container can be used to run an application or to separate tools, libraries, or runtimes needed for working with a codebase. If you open the project in VSCode, you can reopen the folder in the development container and have a full working environment.","title":"Developing inside a Container in VSCode"}]}